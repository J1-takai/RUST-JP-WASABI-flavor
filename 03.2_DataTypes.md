<div style ="text-align: right">第3章 一般的概念</div>

---

<br>
<br>  

# 3.2. データ型 Data Types  

<br>  

Rustで用いられている値はどれも何らかの**データ型**を持っており、その型によって、Rustはデータがどのように規定されているのかを知り、どう処理するのかを判断しています。では、二つのデータ型、「スカラー型（scalar）」と「複合型（compound）」、を見ていきましょう。  

Rustは**静的型付き**プログラミング言語であることに注意してください。つまり、コンパイル時にすべての変数の型を知る必要があるということです。コンパイラは、通常、値とその使い方によって、私たちがどの型を用いたいと考えているかを推論できます。但しいくつかの型が考えられる場合、例えば第2章の「［推測値を秘密の数字と比較する](<https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number>)」で用いた「文字列型 'String'」を'parse'を使って「数値型」に変換する場合には、私たちは次のように型注釈を付け加える必要があります。

> 《訳注》**静的型付け**：　値やオブジェクトの型安全性をコンパイル時に検証する方式を言います。  

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

もし型注釈をここで行なわない場合、Rustは次のようなエラーを表示します。これは、どの型を意図しているか知るためにコンパイラが追加の情報を求めているのです。  
このエラーは、以下の実行結果が示すように「**変数の型は'可変化'出来ない**」ということです。

```rust
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
※ エラー発生：　「型注釈」が必要です
 --> src/main.rs:2:9    ※ 発生箇所：　2行目9桁目
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
            ※ 変数「guess」に「型」指定を検討してください

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error

```

異なるデータ型に異な型注釈を与えているのが分かるでしょう。  
<br>

## スカラー型 Scalar Types  

**スカラー**型は単一の値を表します。Rustには整数型、浮動小数点型、ブール型、文字型、の四つの主要なスカラー型があります。他のプログラミング言語でも使われていることにお気づきかもしれません。早速、Rustでどのような働きをするか見てみましょう。

>《訳注》　**スカラー** = 長さ、面積、重さなど、大きさだけで定まる量。  

<br>

### **整数型**

**整数**は小数部分のない数値です。すでに第2章で、整数型をひとつ（`u32`型）使用しました。この`u32`型宣言では、その値が「符号なし」整数で32ビットの大きさであることを示しています（因みに「符号付き」整数型の場合は、`u`ではなく（`u`は「符号なし <u>*u*</u>nsigned」の`u`）、`i`で始まります（`i`は「普通の整数 <u>*i*</u>nteger」の`i`)。次表3-1は、Rustに組み込まれている「整数型」の一覧です。整数値の型を宣言する場合、どの型も使えます。  

<br>

**表3-1：　Rustの整数型**

|長さ|符号付き|符号なし|  
|:---:|:---:|:---:|  
|8 ビット|`i8`|`u8`|  
|16 ビット|`i16`|`u16`|  
|32 ビット|`i32`|`u32`|  
|64 ビット|`i64`|`u64`|  
|128 ビット|`i128`|`u128`|  
|アーキテクチャ依存|`isize`|`usize`|  
|

どの整数型も「符号付き」「符号なし」のいずれかになり、明確な大きさを持っています。「符号付き」「符号なし」とは、その数字が負になれるかどうかを意味しています。言い換えれば、その数値に正負の表示が必要（符号付き）か、正の状態にしかならず、従って正負記号なしで表現できる（符号なし）か、という違いです。ちょうど紙の上に数字を書くような感じです。符号が必要であれば、＋記号や－記号を付けて表示します。ただし、符号の表示がない場合は「正の数値」と考えておいた方が安全です。符号付き数字は「[**2の補数**](https://ja.wikipedia.org/wiki/2の補数)」という表現法を用いて保持されています。  

> 《訳注》　**2の補数**　「補数」とは「元の数字に足すと桁上がりを起こす（位が一つ上がる）最小の数字」のことで、2の補数はコンピュータなどで用いられている2進法（二進数）上で、負の数を表す際に用いられる方法（2の補数は先頭ビット〈数値の左端の桁〉が「1」である場合に負の数を表します）。負の数字を表す他に、補数表現を利用すれば「加算で減算が表現できる」（コンピュータは足し算が得意なので）というメリットもあります。　※ 詳しくは「[✶A-STAR社サイト記事](<https://agency-star.co.jp/column/2-complement>)」を参考に。

それぞれの型の符号付き変数は、二進数の「$-(2^{n-1})$」から「$2^{n-1}-1$」までの範囲の数字が保持可能です(*n*は、それぞれの変数が用いるビット数を表します。たとえば`i8`の場合では、「$-(2^{7})$」から「$2^{7}-1$」までの数字、すなわち十進数の -128 から 127 までを保持できます。符号なし型では「0」から「$2^{n}-1$」になるので、`u8`であれば「0」から「$2^{8}-1$」まで、すなわち 0 ~ 255 です。

**アーキテクチャー依存型**（arch）の`isize`と`usize`は、あなたのプログラムが実行されるコンピュータのアーキテクチャー次第です。すなわち、コンピュータが64ビット機であれば「64ビット」に、32ビット機であれば「32ビット」になります。  

**整数リテラル**（integer literals）は、表3-2に記載されたどの形ででも用いることができます。いくつかの数値型（numeric types）に対応している「数値リテラル」（number literals）では、`57u8`などのように「型接尾辞」（type suffix）を付け加えることができ、型を指定できることに注意してください。「数値リテラル」は、数値を読み易くするために「見かけ上の区切り記号」として`_`を使用することもできます。たとえば、`1_000`のように記述しても`1000`と記載した場合と同じ値を意味します。

> 《訳注》　**整数リテラル**：　「整数直定数」。小数点または指数部を持たない数値で、プログラム内に「そのままの形（リテラル）」で書かれた整数値。なお、数字を直接（リテラル）プログラム内で用いると、それが何を意味する数値なのか不明瞭になりソースコードの可読性が低下する場合があります。このため、プログラムロジックに「リテラル」を埋め込むのではなく、適切な名前をつけた「シンボル定数」を指定し（[第3.1章「定数」参照](/第3.1章%20変数と不変性.md/#定数%20Constants)）、その数字の意図を明解にすることが推奨されています。  

<br>

**表3-2：　Rustの整数リテラル**

|数字リテラル|表記例|備考|  
|:---:|:---|:---:|  
|10進数（Decimal）|`98_222`||  
|16進数（Hex）|`0xff`||  
|8進数（Octal）|`0o77`||  
|2進数（Binary）|`0b1111_0000`||  
|バイト（Byte）|`b'A'`|〔`u8`型のみ〕|  
|  

では、どの整数型を選べばよいのでしょうか？　確信が持てないのであれば、通常は**Rustのデフォルト値（初期設定／標準条件）から始める**のが良いでしょう。**整数型のデフォルト値**は「`i32`」です。アーキテクチャー依存型の`isize`や`usize`を使用する主な状況とは、コレクションにインデックスを付けるというような場合です。

>《訳注》　**コレクション** （collection）：　〔収集・集積、の意〕　複数のオブジェクトを管理するデータ構造。詳細は「[第8章　一般的なコレクション](/第8.0章.md)」を参照してください。

<br>

>**整数オーバーフロー** Integer Overflow  

>いま、0から255までの範囲の値を保持できる`u8`型の変数があるとします。この変数の値を、この範囲を超える値、たとえば 256 に変更しようとすると、「**整数オーバーフロー**」という現象が起こり、つぎのどちらかが起こります。ひとつは「デバッグ・モード」でコンパイルしている場合で、Rustが「整数オーバーフロー」をチェックし、プログラム実行時にこの「整数オーバーフロー」問題があればプログラムが**パニック現象**を起こして停止します。ところで、Rustでは**プログラム・エラーにより動作を中断することを「パニック」と呼びます**。「パニック」については第9章の「[`panic!`で回復不能なエラー](/第9.1章.md)で詳しく学びます。  

>一方、`--release`フラグ付の「リリース・モード」でコンパイルしている場合には、Rustはパニック現象を惹き起こす「整数オーバーフロー」のチェックを行ないません。代わりに、オーバーフローが発生した場合、Rustは「**2の補数ラッピング**（*two’s complement wrapping*）を実行します。これは、手短に言えば、指定された型の最大値を超える値は、その型が保持できる最小値に戻されることです。したがって、`u8`の場合であれば、256 は 0 に、257 は 1 に、という具合に、範囲を一周して最初からに戻ります。したがって、プログラムは「パニック」を起こしませんが、変数の値はあなたが意図したものとは異なることになり、**「整数オーバーフローのラッピング」に依存している処理は誤り**です。  

>「オーバーフロー」の可能性に明示的に対処するためには、「プリミティブ（基本の）数値型 primitive numeric types」の標準ライブラリにある以下の「メソッド」を利用できます。  
>
> * `wrapping_*`メソッドで、すべてのモードで「ラッピング」させる（たとえば`wrapping_add`）  
> * `checked_*`メソッドで、オーバーフロー発生時に `none` 値を返させる  
> * `overflowing_*`メソッドで、オーバーフロー発生時に「その値」と「ブール値」を返させる  
> * `saturating_*`メソッドで、自動的に値を「その変数値の最大値と最小値」に修正する　※《訳注》この処理は、値を飽和値（最大値または最小値）に「飽和する saturate」ので「飽和演算」と呼ばれる。  
> 
>
<br>  


### 浮動小数点型  

Rustには**浮動小数点数**（小数点を持つ数）用の基本型が二つあります。Rustの浮動小数点型は`f32`と`f64`で、それぞれ32ビットと64ビットのサイズがあります。デフォルトの型は`f64`ですが、これは、最近のPCでは`f32`と同程度の処理速度があり、なお且つ、精度を高く出来るためです。すべての浮動小数点型は「符号付き」です。  

以下は実際の浮動小数点数の事例です。

```rust
fn main() {
    let x = 2.0;        ※ こちらは`f64`型（デフォルト設定）

    let y: f32 = 3.0;   ※ こちらは`f32`型を指定
}
```

浮動小数点数は、米国標準規格『IEEE 754 浮動小数点算術』に従って表されています。`f32`は「単精度浮動小数点数」、`f64`は「倍精度浮動小数点数」です。  
<br>

### 算術演算 Numeric Operator

Rustはすべての数字型に対応する、足し算、引き算、掛け算、割り算、剰余などの基本的な数学演算を備えています。整数の除法では、端数が一番近い整数値に切り捨てられます。次のコード例は、`let`文のなかでどのように算術演算が用いられているのかを示しています。 

```rust
fn main() {
    ※ 足し算（addition）、変数名sumは「合計」の意
    let sum = 5 + 10;

    ※ 引き算（subtraction）、変数名differenceは「差」の意
    let difference = 95.5 - 4.3;

    ※ 掛け算（multiplication）、変数名productは「積」の意
    let product = 4 * 30;

    ※ 割り算（division）、変数名quotientは「商」の意
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3;
    ※ こちらの結果は「0」、変数名flooredは「切り捨て」の意

    ※ 余り（remainder）、変数名remainderは「剰余」の意
    let remainder = 43 % 5;
}
```

`let`文の中の計算式は「数学演算子」を用いて単一の値に評価され、それが変数に結び付けられています。**[付録 B](/付録B.md)**には、Rustが用いるすべての演算子がリストされています。  

<br>
### ブール型（論理値型） The Boolean Type  

他のほとんどのプログラミング言語同様、Rustの「**ブール型**」も、「真 `true`」か「偽 `false`」か、の二値を持っています。ブール値のサイズは 1 バイトです。 Rustの「ブール型」は `bool`を使って指定します。

```rust
fn main() {
    let t = true;

    let f: bool = false;    ※ 明示的に型注釈を行なっています
}
```

「ブール値（論理値）」の主な用途は、`if`文のような条件式の中にあります。`if`文がどのようにRustの中で用いられるのかについては、『**[第3.5章 制御フロー](/第3.5章%20制御フロー.md)**』で取り扱います。

<br>

### 文字型（一文字型） Character Type  

Rustの`char`型は、Rust言語で最も原始的な「アルファベット型」です。以下に、`char`型値の宣言例をお見せします。

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```

`char`の内容値（リテラル）は、二重引用符（" "）を用いる文字列string型とは異なり、**「一重引用符（' '）」で囲まれる**ことに注意してください。Rustの`char`型は4バイトの大きさがあり、一つの「**ユニコード文字**（Unicode Scalar Vaue）」を表せます。これは、アスキー・コード（ASCII）だけの場合より遥かに多くの文字を表現できます。たとえば、アクセント記号付き文字、中国語文字（繁体字・簡体字）、日本語文字（漢字・ひらがな・カタカナ）、韓国語文字（ハングル）や絵文字、ゼロ幅スペース文字などは、すべてRustの`char`値として有効です。ユニコードには、`U+0000`から`U+D7FF`までと`U+E000`から`U+10FFFF`までの範囲に登録されている膨大な文字データがあります。しかしながら、実際には「文字」という概念がユニコードにはないため、あなたが人間の直観として理解している「文字」とRustの用いる`char`というものが上手く一致しないかもしれません。この件に関しては『**[第8.2章 文字列でUTF-8でエンコードされたテキストを保持する](/第8.2章%20文字列でUTF-8でエンコードされたテキストを保持する.md)**』で詳しく説明します。  

> 《訳注》　**ユニコード文字**：　Unicode（ユニコード）は、各国が個別に定めていた独自文字を世界共通で用いられるように定めた文字コードの国際規格。ユニコードでは、文字コード番号の0番～10FFFF番までの範囲に111万4112個分の文字が登録できるようになっているようです。英語表記の「ユニコード・スカラ値」というのは、各文字コードに格納されているその文字の値の事です。
> 
> 《訳注》　**アスキー・コード**  ASCII：　情報交換用米国標準コード（American Standard Code for Information Interchange）の略。ラテン文字（アルファベット）を中心としたコンピュータの黎明期からある文字コードで、7ビット（7桁の2進数）で表されています（0から127までの128種類）。

<br>

## 複合型 Compound Types

**複合型**は複数の値をひとつの型にまとめることができます。Rustでは「タプル型 Tuple Type」と「配列型 Arrays」という基本的な複合型をふたつ用意しています。

<br>
### タプル型 Tuple Type

「**タプル**」（「一揃いの要素」の意味）は、さまざまな型のいろいろな値をひとつの「複合型」にまとめる一般的なやりかたです。「タプル」は固定長で、一旦宣言されたら、サイズを変更できません。

「タプル型」は、丸括弧の中にコンマ〔,〕で区切られた値のリストです。タプルの中の各項はそれぞれの型を持ち、個々の値の型は同じである必要はありません。以下の例では、「型注釈」を追加してあります。
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);    ※ 変数名の後でデータの型を指定しています。
}
```

変数`tup`は<u>タプル全体に結び付け</u>られています。というのもタプルは単一の複合型と見做されているためです。個々の値をタプルから取り出すためには、以下のようにパターン・マッチングを用いて、タプルの値を分解していきます。
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

このプログラムでは、最初にタプルを生成し、内容を変数`tup`に結び付けています。次にパターンを用いて`let`文で変数`tup`の内容を取得し、3つの分割された値「`x`」「`y`」「`z`」に振り分けます。この操作を「**分配** *destructuring*」呼びます。一つのタプルを三つの部分に分割しているからです。最後にプログラムが`y`の値、`6.4` を表示します。

また、ピリオド〔.〕と要素の位置番号を使ってタプルの各要素を直接入手する方法もあります。たとえば、

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;     ※ 変数「five_funndored」（五百）を変数xの0番（先頭）の要素に結び付けています

    let six_point_four = x.1;   ※変数「six_point_four」（6.4）を変数xの1番の
    要素（真ん中）に結び付けています。

    let one = x.2;  ※ 同様に変数「one」に変数xの2番の要素（最後、3番目）に結び付けています。
}
```

今度のプログラムではタプル`x`生成し、次に各要素に対する変数を作成、それぞれの要素の検索番号（添え字）に結び付けます（`x`の0番目、`x`の1番目、`x`の2番目、のように）。**ほとんどのプログラミング言語同様に、タプル要素検索番号（添え字）は「0」からはじまる**ことに注意しましょう。

何の要素〔値〕をもたない空のタプルは、一つの値だけを持つ特別な型で、`()`と書かれます。このタイプは「ユニット型」（unit type）と呼ばれ、その値は「ユニット値」と呼ばれています。 プログラムの処理式は、他の値を何も返さない場合、この「ユニット値」を返すことになっています。

<br>

### 配列型 Array Type

いくつかの値の集合体を取り扱うもう一つの方法は、「**配列**（Array）」を用いることです、タプルとは異なり、**配列内の各要素は同一の型を持っていなければなりません**。また、他のプログラミング言語の配列とは異なり、Rustの配列は固定長です。

配列の各要素は、カンマ区切りで角括弧（[ ]）の中に書きます。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

「配列」は、データを「**ヒープ** heap」ではなく「**スタック** stack」に割り当てたい場合、または常に一定数の要素だけで処理したい場合に役立ちます（スタックとヒープについては『**[第4.1章 所有権とは](/第4.1章%20所有権とは.md)**』で詳しく説明します）。しかし、配列は「**ベクタ型** vector type」ほど融通が利きません。ベクタ型は標準ライブラリによって提供されている「**コレクション型** collection type」に似たもので、そのサイズを大きくも小さくもできます（可変長）。「配列」と「ベクタ」型、どちらを使うべきか迷った場合は、多分「ベクタ型」が良いでしょう。ベクタについては『**[第8.1章 ベクタで値のリストを保持する](/第8.1章%20ベクタで値のリストを保持する.md)**』にて詳しく説明します。

> 《訳注》　**ヒープ** （heap）：　〔堆積、の意〕　ヒープ領域。コンピュータプログラムが実行時に使用するメモリ領域の一つで、任意に確保や解放を繰り返すことができるものを指します。
> 
> 《訳注》　**スタック** （stack）：　〔積み重ね、の意〕 スタック領域。コンピュータプログラムが実行時に使用するメモリ領域の一つで、データの出し入れが「後入れ先出し（または）先入れ後出し」（LIFO: Last In First Out / FILO: First In Last Out）の順序でしか行なえないものを指します。
> 
> 《訳注》　**ベクタ** （vector）：　〔ベクトル・方向量、の意〕　プログラミングの世界では、同じ型のデータを一列に並べたデータ構造をいいます。ベクタ型は可変長の値を並べて保持できなす。この反対の概念が「スカラー」（単体の値）。 
> 
> 《訳注》　**コレクション型** （collection type）：　〔収集、の意〕　データ量がプログラムの実行にあわせて伸縮可能である複数のデータを一つにまとめたデータ構造の総称。

 <br>

要素の数を変更する必要がないと判っている場合は、「配列」が便利です。たとえばプログラムの中で「各月の名前」を使う場合、月の数は常に12と判っているので、ベクタよりも配列を使うことになるでしょう。

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

次のように、`[i32; 5]`のように、角括弧を使って「要素のデータ型・セミコロン・配列の要素の数」のように書くと、

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

`i32`が配列内の要素のデータ型を、セミコロンの後の`5`が要素の数（この場合は5つ）を示します。

また、`[3; 5]`のように、角括弧の中にまず初期値、続いてセミコロン、さらに配列の大きさを指定することで、各要素が同じ初期値の配列として初期化することも可能です。

```rust
let a = [3; 5];
```

この例では配列名`a`が`5`つの要素を含み、全要素が初期値`3`に設定されます。これは、`let a = [3, 3, 3, 3, 3];`と書くのと同じ事ですが、より簡潔に表記できます。

<br>

### 配列の要素にアクセスする

配列は、スタック・メモリ上に配置された既定のデータ・サイズを持つ一塊のメモリです。その配列の各要素には、「添え字」を使ってこのようにアクセスします。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

`first`という名前の変数は値`1`を受け取ります。なぜなら、それがこの配列での添え字`[0]`番目の値だからです。同様に変数`second`は、配列内の添え字`[1]`番目の値`2`を受け取ります。
> 《訳注》　添え字は「0」から始まることを思い出しましょう。

<br>

### 配列要素への無効なアクセス  
<br>


配列の終わりを超えて、その配列の要素にアクセスした場合、どうなるでしょうか？　第2章の数当てゲームのプログラムに似た次のコードを実行して見てください。

<img src="https://doc.rust-jp.rs/book-ja/img/ferris/panics.svg" width="40px" align="right">

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```

このコードは問題なくコンパイルされます。このコードを`cargo run`で実行し、0、1、2、3、または4を入力すると、プログラムは入力された添え字に対応するその配列中の値を出力します。しかし、たとえば「10」のように、配列の最後の要素数を超えた数字を入力した場合には、次のようなメッセージが現れることでしょう。

    thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
    
    `main`実行プロセスでパニック発生、「範囲外アクセス」：　配列の要素は5つですが、添え字番号が「10」でした。 発生個所 src/main.rs:19行:19文字目
    
    注意: バックトレースを表示するために環境変数`RUST_BACKTRACE=1`をつけて実行のこと

添え字指定時の無効値によるプログラム**実行時エラー**です。プログラムは「エラー・メッセージ」を表示し、実行プロセスを終了するため、最後の`prinln!`命令を実行しません。添え字を使って要素にアクセスすると、Rustはあなたが指定した添え字が配列の長さ（要素数）よりも小さいかどうかを確認します。添え字が要素数と同じか大きい場合に、Rustは「パニック」状態になります。この確認処理は、プログラムの実行時に行なわれています。なぜなら、特に今回のプログラム例のような場合では、ユーザーがプログラムを実行した時点でどのような添え字値を用いるのかを、コンパイル時点でコンパイラが知り得ないからです。

これが、Rustの実行時メモリ安全性原則の事例です。多くの低級言語では、このような確認処理は行なわれていないので、無効な添え字が用いられても、無効なメモリへのアクセスを可能にしてしまいます。Rustは、このようなエラーに対して、メモリ・アクセスを許して処理を継続させることなく、即座に処理を終了することであなたのプログラムを保護しています。第9章では、Rustのエラー処理について、より深く説明します。

<br>
<br>

<hr>

<div align="center";>

[≪≪ 前に戻る](/03.1_Variables.md)　　  | 　　[《目次》](/00.0_TOC.md)　　| 　　[次に進む　≫≫](/03.3_Functions.md)
</div>
