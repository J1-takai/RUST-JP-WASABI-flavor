<div style ="text-align: right">第4章 所有権を理解する ①</div>

---

<br>
<br>  

# 4.1. 所有権とは  

<br>  

**所有権とは、Rustプログラムのメモリ管理の根幹となる一連の規則のこと**です。プログラムはどれも、実行中に利用するコンピュータのメモリを管理しなければなりません。プログラムの実行状況に応じて不要となったメモリ領域を定期的に探索する「ガベージ・コレクション」方式を用いるプログラム言語や、プログラマーが自分でメモリ領域を割り当てたり解放したりするプログラム言語もあります。Rustは第三のアプローチをしています。つまり、コンパイラがチェックする一連の規則を適用した「所有権システム」を通してメモリを管理します。もし規則のどこかで違反が見つかれば、プログラムはコンパイルされません。所有権の機能が、実行中のプログラムの動作速度に影響することはありません。

「所有権」は多くのプログラマーにとって全く新しい考え方なので、慣れるまでには時間が必要です。ありがたいことに、Rustやその所有権の規則に慣れれば慣れるほど、安全で効率的なプログラムが自然と書けるようになります。挫けずに行きましょう。

所有権について理解できると、Rustの持つ独特の機能を理解するための強固な基礎が得られたことになります。この章では、非常に一般的なデータ構造である「文字列（strings）」に重点を置いた事例を通して「所有権」について説明をしていきます。

<br>

### スタックとヒープ


    多くのプログラミング言語では、「スタック」メモリとか「ヒープ」メモリとかについて考えることはあまりありません。しかし、Rustのようなシステム・レベルのプログラミングで用いられる言語では、ある値がスタック・メモリ上にあるのかヒープ・メモリ上にあるのかによって、どのように言語が振る舞い、なぜ特定の判断を行なわなければならないのかに影響します。この章の後半での所有権の記述は、スタックとヒープとに関連していますので、ここで簡単に説明しておきます。

    「スタック」も「ヒープ」もプログラムが実行時に利用するコンピュータのメモリ領域のことですが、その構成が異なっています。「スタック」はデータの値を受け取った順番に格納（一時保管）し、逆の順序で吐き出します。この方式を「**後入れ先出し** LIFO」と呼びます〔皿が積み重なっているところを想像してください。皿を受け取り収納する場合、皿は上に積み重ねられます。皿を取り出すときには一番上の皿から行ないます。重ねられた皿の途中や一番下から取り出すのが上手く行かないのと同じです〕。スタック・メモリにデータを追加することは「スタック上に《プッシュ》する」といい、データを取り除くことを「スタックから《ポップ》する」と表現します。スタック上に保存されるすべてのデータはサイズの判っている固定長のデータでなければなりません。コンパイル時にサイズが不明のデータやサイズが変わる可能性があるデータは、スタックではなくヒープに保存しなければなりません。

> 《訳注》　**スタック上に《プッシュ》する**：　原文では *pushing onto the stack* 〔スタックの上に押し載せる、の意〕
> 
> 《訳注》　**スタックから《ポップ》する**：　原文では *popping off the stack* 〔スタックからひょいと取り外す、の意〕

    「ヒープ」はスタックほど整然としてはいません。ヒープ・メモリ領域上にデータを保存する場合、まず、その保存スペースを要求します。するとメモリ割り当てプログラムがヒープ上に十分な大きさの空きスペースを見つけ、その場所に使用中の表示をしたうえで、「ポインタ」（その保存場所のアドレスのことです）を返します。このプロセスは「ヒープの割り当て」と呼ばれますが、省略して「割り当て」ということもあります（なお、スタック上へデータを《プッシュ》することは、「割り当て」ではありません）。ヒープの場所を示すポインタはサイズの判っている固定長のデータなので、ポインタはスタックに保存することができますが、実際のデータが必要な場合には、ポインタの示すアドレス（データの保存場所）を辿って行かなければなりません〔レストランで席を依頼するところを想像してください。入店し必要席数を伝えると、店員は全員座れる空きテーブルを見つけ、その席まで案内してくれます。もし誰かが遅れてくる場合でも、店員に皆がどの席にいるのか尋ねれば、その席を見つけることができるのと同じです〕。

    「スタックに《プッシュ》する」ほうが「ヒープに割り当てる」よりも高速です。なぜならば、メモリ割り当てプログラムが新しいデータを保存する場所を一々探す必要がないからです。保存場所はいつでもスタックの一番上なのです。これに対して、ヒープに領域を割り当てるには多くの作業が必要です。メモリ割り当てプログラムは、まずデータを保管するのに十分な大きさのスペースを見つけ出し、次のデータの割り当て準備のために「管理簿をつける」必要があるためです。

    ヒープ中のデータへのアクセスも、スタック上のデータ・アクセスより遅くなります。ポインタの示すアドレスに従って格納場所まで辿り着く必要があるためです。現代のプロセッサはメモリ内の移動が少ないほど高速です。先程のレストランの例え話を続けて、あちらこちらのテーブルから注文を受けているレストランの接客係を考えてみましょう。一つのテーブル全員の注文を取ってから、次のテーブルへ移るのが最も効率的です。Aテーブルで注文を一つ受け、Bテーブルから別の注文を取り、またAテーブルで次の注文を貰い、再びBテーブルに行って注文を受領する…というやりかたでは、非常に遅くなります。同様に、プロセッサは、データ同士が離れ離れになっている場合よりも（ヒープ領域上のデータはそうなっている可能性があります）、データの近くに次のデータがある場合の方が（スタック上のデータのように）、より早く処理できます。

    プログラムが関数を呼び出す場合、（ヒープ上のデータ場所を示すポインタも含めた）関数に渡される値やその関数のローカル変数は「スタック上に《プッシュ》」され、関数処理が終了するとそのような値は「スタックから《ポップ》」されます。

    メモリ不足に陥らないように、プログラムのどの部分がヒープ上のどのデータを使っているかを把握し、ヒープ上の重複データ量を最小限に抑え、ヒープ上の未使用データを一掃することは全部、この章の「所有権」が対処する問題です。一旦「所有権」を理解すれば、スタックのこともヒープのことも然程考える必要はありませんが、「所有権」の主目的がヒープ・データの管理にあることを知れば、「所有権」がこれから説明するように機能する理由の説明に役立ちます。

<br>


> 《参考》　**関数の定義**
> 
> 「所有権」の話の前に、「関数の書式の違い」を再確認しておくと、文中のプログラム例の理解が深まるかもしれません。［☞ [参考記事](https://atmarkit.itmedia.co.jp/ait/articles/2110/28/news006.html)］
> 
> ① **引数も戻り値もない関数**の場合<br>
> 　【例： `fn main() { ... }` 】
> 
> + 「`fn`」と関数名を記述
> + 関数名は**スネークケース**（**全て小文字**を用い、単語をアンダースコア〈 `_` 〉で繋げた形式）
> + 続けて空の丸括弧「`()`」を付けます
> + 波括弧「`{ }`」の中に処理内容を記述
>
> ② **引数のある関数**の場合<br>
> 　【例： `fn takes_ownership(some_string: String) { ... }` 】
> 
> + 関数名に続く丸かっこの中に引数（parameter：仮引数）を**型名とともに**列挙します
> + 引数が2個以上になる場合にはカンマ（ `,` ）で区切ります
> + **引数の型名は省略できません**
> 
> ③ **戻り値のある関数**の場合<br>
> 　【例： `fn calculate_length(s: String) -> (String, usize) { ... }` 】
> 
> + 関数に戻り値がある場合、**アロー演算子**「 `->`」を利用して**戻り値の型を指定**します
> 


<br>

## 所有権の規則

最初に、「所有権の規則」について見ておきましょう。これから説明する各規則のプログラム例を学習する際にも、この規則に留意してください。

+ Rustの各値には、「**所有者**」があります。
+ いかなる時も、存在できる所有者は一人だけです。
+ 所有者が有効範囲から外れたら、その値は破棄されます。

<br>

## 変数の有効範囲（スコープ）

基本的なRustの構文については既に学んだので、ここからのプログラム例からは、`fn main()`を記載しません。事例を実際に試しながら進める場合には、各プログラム例を `main`関数の中に手作業で書き込んでください。このようにする理由は、プログラム例を簡潔にし、定型の全体表現ではなく、実際の詳細部分に焦点を当てるためです。

所有権の最初の例として、変数の有効範囲（スコープ）を見ていきます。 「スコープ」とは、ある項目が有効となるプログラム内の範囲のことです。 次のような変数を考えましょう。

```rust
let s = "hello";
```

変数 `s` は「**文字列リテラル**」を示し、文字列の値はプログラム内に直接記述できます。この変数は、宣言されたところから現在の「スコープ」の終わりまで有効になります。リスト4-1では、変数 `s` が有効である部分を注記したプログラム例です。

```rust
    {   ※ ここでは変数 s はまだ有効ではありません。宣言前です。
        let s = "hello";
        ※ 変数 s はここ以降、有効です

        // 変数 `s`での処理を記述

    } 　※ スコープはここで終了。変数 s はもう有効ではありません。
```

##### リスト4-2：　変数とその有効範囲（スコープ）

<br>

言い換えると、ここには2つの重要な時点があります。

+ 変数 `s` がスコープの中に入った時点で、有効になります。
+ 変数 `s` は、それがスコープの外に出る時まで、有効のままです

現時点で、「スコープ」と「変数が有効な場合」の関係は、他のプログラミング言語と同様です。 では、これに加えて、文字列型（String型）を導入して理解を深めましょう。

<br>

## 文字列型（String型）

所有権の規則を説明するには、第3章の「[データ型](/03.2_DataTypes.md)」で見たタイプよりも複雑なデータ型を検討する必要があります。これまでの型はすべてサイズが既知で、スタック・メモリ領域に格納され、スコープ（有効範囲）が終わればスタック領域から除外されました。また、プログラムの別の部分で同じ値を異なるスコープで使用したい場合には、その型を素早くかつ普通に新しい独立した**インスタンス**として複製できました。しかし、これから、ヒープ・メモリ領域に格納されているデータを調べて、Rustがそのデータを除去するタイミングをどのように判断しているのかを調べたいと思います。それにはString型が最適な事例です。　《インスタンスの説明は [第5.1項](/05.1_DefiningStructs.md) にあります》

> 《訳注》　**インスタンス** （instance）：　〔実例・置き換え表現、の意〕　プログラム内であらかじめ定義した処理内容・データ構造をメイン・メモリ上に呼び出し、処理可能な状態にしたものをいいます（**実体**とも呼ばれています）。これは、プログラム上の定義だけでは「絵に描いた餅」状態〔抽象的概念〕であるので、コンピュータ上にその複製物を一旦作成し（**インスタンス化**といいます＝「実体化」）、「仮想的な実物」に置き換えて処理を実施するという考え方です。

ここでは、`String`型の所有権に関連する部分だけに注目して説明します。ここで述べる内容は、標準ライブラリによって提供されているものであれ、ご自身で定義したものであれ、`String`型だけではなく複合的なデータ型すべてに当て嵌まります。より詳しい `String`型の内容については、[第8章](08.0_CommonCollections.md)にて説明いたします。

直接プログラムに書き込む文字列「**文字列リテラル**」の事例については既に学習しました《「[所有権の有効範囲](#変数の有効範囲スコープ)」に出ている `"hello"`のように直接プログラムに書き込まれた文字列のことです》。「文字列リテラル」は非常に便利な方法ですが、テキスト・データを取り扱うすべての場合に適している訳ではありません。理由のひとつは、**文字リテラルは変更できない**ことです。別の理由は、プログラム作成時に全部の文字列の内容が判っているわけではないことです。たとえば、ユーザーの入力を取り込み保存したい場合のように。このような状況のために、Rustでは二つ目の文字列型である `String` が用意されています。この型は、ヒープ領域に割り当てられたデータを扱うので、コンパイル時にはサイズが不明なテキストでも格納できます。次のように `from` 関数を用いると、文字列リテラルから `Stirng` 型データを生成できます。

> 《補足》 **二つ目の文字列型**：　ここで「二つ目の」とわざわざ書かれている意図が不明ですが、Rustには文字列型を扱う型として `String` と `&str` の2つがあります。ひとつは「ある文字列の位置」を指す（参照する）**固定長の** `&str` 型で、もうひとつが「ヒープメモリ上に確保される文字列」を指す**可変長の** `String` 型です。`&str`型については[第4.3項](/04.4_SliceType.md)に説明があります。


```rust
let s = String::from("hello");
```
二重コロン演算子（`::`）は、同一プログラム領域内では識別のために異なる変数名を付けなければならないという「**名前空間**」の決まりのなかで、`string_from`のような長々とした名前を付ける代わりに、この特定の `from` 関数を `String` 型だけで使えるようにしています。このような表記法は、「[第5.3項 メソッド記法](/05.3_MethodSyntax.md)」で詳しく説明します。また、**名前空間**については、「[第7.3項 モジュールツリーの要素を示すためのパス](/07.3_ModuleTree.md)」の中で、モジュールと名前空間について解説するときに触れていきます。

さて、この種類の文字列は「可変」にできます。

```rust
    let mut s = String::from("hello");

    s.push_str(", world!"); 
    ※ push_str()によってリテラルを`String`に付け足しています

    println!("{}", s);
    ※ ここで「`hello, world`」と出力されます
```

違いが判りますか？　なぜ `String` 型は可変化できるのに、リテラルではできないのでしょう？　この違いは、この二つの型のメモリの取り扱い方法にあります。

<br>

## メモリと保存領域の確保

「文字列リテラル」では、コンパイル時にその内容が判明しているので、そのテキスト（文字列）はプログラム内に直に書き込まれで最終的な実行ファイルに含まれています。このため、文字列リテラルは高速で効率的に動作します。しかし、このような特徴は文字列リテラルが「不変」であるからこそできることです。残念ながら、コンパイル時にサイズが不明なものやプログラムの実行時にサイズが変わるようなテキスト（文字列）は、実行可能な状態でメモリに配置することはできません。

`String`型では、可変長のテキストに対応するために、コンパイル時には不明なメモリ量を、ヒープ領域に確保しその内容を保持することができます。つまり、

+ メモリは実行時にメモリ割り当てプログラムにより確保されます
+ `String`での利用が完了したときには、メモリ割り当てプログラムに対してメモリ領域を変換する仕組みが必要です

この一番目の処理は私たちが自分で行なっています：　`String::from`関数を呼び出すと、実行時に必要なメモリを要求しているのです。この手順は、プログラミング言語では極めて共通的なやり方です。

ところが、二番目の部分は異なります。**ガベージ・コレクション（GC）** 機能を有するプログラミング言語では、GC機能が使われなくなったメモリ領域を追跡・解放してくれるので、私たちはメモリ領域の返却について考える必要がありません。GC機能を持たないプログラミング言語では、メモリ領域が不要となった時点で、メモリを要求した場合と同じように、メモリ開放命令を明示的に実行して解放するはプログラマの役目です。が、この処理を正確に行なうのは、歴史的にも困難なプログラム上の問題なのです。もしメモリの解放を忘れれば、メモリ領域が浪費されます。解放が早すぎても、変数が無効になります。2回解放してもバグになります。メモリの確保命令とメモリの解放命令は完全に一対一になっていなければいけません。

Rustでは異なるアプローチを採っています。メモリ領域を使っている変数がスコープ（有効範囲）から外れると、そのメモリ領域は自動的に解放されます。次の例は、リスト4-1の「文字列リテラル」の代わりに `String`型を用いたスコープの説明です。

```rust
    {
        let s = String::from("hello");
        ※ 変数`s`はこのポイント以降有効です。

        ※ 変数`s`を用いた処理を記述する部分
    }   ※ スコープ（有効範囲）はここで終了、変数`s`はもう有効ではありません。
```
`String`型が確保したメモリ領域を解放できる打って付けの場所があります：　変数`s`がスコープの外に出るところです。変数が有効範囲を離れると、Rustは私たちに代わって特別な関数を呼び出します。この関数は `drop` というもので、`String`型を使用した場合、この部分にメモリを解放するプログラムを記述することも出来ます。Rustは「閉じ波括弧 }」の部分で自動的に `drop`関数を呼んでいます。

    【原文注記】　C++言語では、このように、要素のライフタイム（寿命）が終わるときにリソースを自動解放する方法を「RAII」と呼んでいます（Resource Acquisition Is Initialization の略。「リソース取得とは初期化のことである」のような意味。）。C++のRAIIを利用したことがあれば、Rustの `drop` 関数もお馴染みのものでしょう。

この方法はRustプログラムの書き方に大きく影響しています。現時点では単純に見えているかもしれませんが、ヒープ・メモリに格納されたデータを複数の変数で使い廻すような複雑な状況の場合、プログラムの挙動が予期しないことになりかねません。これからそうした状況について考察してみましょう。

<br>

### 複数の変数とデータの関係 ①：「値の移動 Move」

Rustでは、複数の変数が同じデータに異なる方法で作用することがあります。リスト4-2の**整数を用いた例**を見てみましょう。

```rust
    let x = 5;
    let y = x;
運でrてぇこヴぇｒｓ```

##### リスト4-2：　変数 `x` の整数値を `y` に代入する

<br>

このプログラムで何が起こっているかは想像できるでしょう。値`5`を変数`x`に結び付け、`x`の値を複製して、`y`と結び付けている、と。二つの変数`x`と`y`は、ともに`5`に等しくなります。これが実際に起こっていることですが、整数は単純な既知で固定長の値で、この二つの値`5`はスタック・メモリに保管されます。

次に**文字列型`String`を用いた例**を見てみましょう。

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```

見掛けは同じように見えます。なので、同じように動作すると思われるかもしれません。2行目では`s1`の値を複製し、それを`S2`に結び付けている、と。ところが実際はそうではありません。

図4-1を見て、見えないところで `String` に何が起こっているのかを確かめましょう。`String` は3つの部分から成り立っています。左側には、文字列の内容が保持されているメモリ領域へのポインタ（アドレス）、データ長、沿うデータ容量。この一連のデータは「スタック」に保管されています。右側は文字列の内容を保持する「ヒープ」のメモリです。

<img src="https://doc.rust-lang.org/book/img/trpl04-01.svg" width="250px">

##### 図4-1：`s1`に結び付けられている値`"hello"`を保持する`String`のメモリの様子

<br>

データ長（len）は `String` にデータが現在使用しているメモリ量を「バイト数」で示します。総データ容量（capacity）は、`String` がメモリ割り当てプログラムから受け取ったメモリの総量を表しています。データ長と総データ容量が異なっていると問題がありますが、ここでは関係がありませんので、現時点では、総データ容量については無視して構いません。

さて、`s1`を`s2`に代入する場合、`String`のデータが複製されますが、これは実際のところ、**「スタック」上にあるポインタ、データ長、総データ容量だけをコピーしている**のです。ポインタが指し示す「ヒープ」上のデータをコピーしているのではありません。言い換えると、メモリ上の状態は図4-2のようになります。

<img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" width="250px">

##### 図4-2：変数`s2`のメモリには、`s1`のポインタ、データ長、総データ容量のコピーが作られている

<br>

メモリの状態は、図4-3（Rustがヒープ上のデータも複製した場合）のようにはなりません。Rustがヒープ上の実際のデータをコピーしてしまうと、ヒープ上に格納されているデータが膨大なデータ量であった場合、`s2 = s1` のような演算が処理時間という点で非常に大きな不利益を被るからです。

<img src="https://doc.rust-jp.rs/book-ja/img/trpl04-03.svg" width="250px">

##### 図4-3：`s2 = s1`の処理でRustがヒープ上のデータもコピーした場合

<br>

少し前に、変数がスコープ（有効範囲）の外に出てしまうと、Rustは自動的に `drop` 関数を呼び出して、その変数が使用していたヒープ・メモリを解放する、という話をしました。しかし、図4-2が示すように、二つのデータ・ポインタは同じヒープ・メモリの場所を示しています。そこが問題です：　`s2` と `s1` がスコープ外となったときに、この二つの変数はともに同じメモリを解放しようとします。これは「**二重解放**」エラーとして知られているもので、以前に述べた「メモリ安全性」にかかわるバグの一つです。メモリを二度解放すると、メモリ破損に繋がり、セキュリティ上の脆弱性を生む要因になります。

メモリの安全性を確保するため、`let s2 = s1` 行の後では、Rustは `s1` をもはや有効とは見做しません。これにより、`s1`がスコープ外になっても、Rustは何も解放する必要がなくなります。`s2`が生成されたあとで、`s1`を使うとどうなるが確認してください（動作しないはずです）：

<br>

<img src="https://doc.rust-lang.org/book/img/ferris/does_not_compile.svg" width="40 px" align="right">

```rust
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
```

おそらく次のようなエラーメッセージが表示されたはずです。Rustは無効化された**参照**を許可しないのです 《「参照」については次節4.2に解説があります》。

```rust
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
※ エラー：　移動された値「s1」の借用
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
            ※ 「s1」は`String`型で`Copy`属性が付与されていない型であるため、値の移動（`move`）が発生します。
3 |     let s2 = s1;
  |              -- value moved here
                ※ 値はここで`s2`に移動します。
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
                            ※ ここで移動された値（`move`後の値）を要求しています 
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
  ※ 注記：　このエラーはマクロ「`$crate::format_args_nl`」に導入されました（評価版Rustでは、「-Z macro-backtrace」を実行すれば詳細情報が得られます）。

For more information about this error, try `rustc --explain E0382`.
※ このエラーについては、`rustc --explain E0382`を実行してください。 
error: could not compile `ownership` due to previous error
※ エラー：　前述のエラーのため、プログラム ownership をコンパイルできません。
```

他のプログラム言語で「**浅いコピー**（shallow copy）」「**深いコピー**（deep copy）」という言葉を聞いたことがあれば、ポインタ・データ長・総データ容量だけをコピーして実際のデータをコピーしないというRustの考え方は「浅いコピー」を行なっているように聞こえるかもしれません。しかし、Rustの場合、一つ目の変数の無効化も併せて行なっているので、「浅いコピー」とは呼ばずに、「**移動 move**」と言っています。今回のプログラム例では、`s1`が`s2`に移動された、となります。実際にメモリで起こっていることを示したのが 図4-4 です。

<img src="https://doc.rust-lang.org/book/img/trpl04-04.svg" width="250px">

##### 図4-4：　変数`s1`が無効化されたあとのメモリの様子

<br>

これで複数の変数による「メモリの二重解除」問題は解消されました。変数`s2`だけが有効なので、`s2`がスコープ外に出ると、`s2`だけがメモリを解放して、処理完了です。

付け加えると、この背景には設計上の選択もあります。Rustでは決してデータの **「深いコピー」を自動的には行なわない** ので、実データ部分がコピーされることがなく、Rustの実行性能の観点からは、自動コピーはどれも速度やリソースを犠牲にすることがないと考えられます。

<br>

### 複数の変数とデータの関係 ②：「値の複製 Clone」

もし、`String`型のデータを「<ruby>深い<rt>ディープ</rt></ruby>コピーしたい場合、つまり、スタックに格納されたデータ〔＝ポインタ・データ長・総データ容量の実データ格納場所情報〕だけでなく、ヒープに格納されたデータ〔＝データの実際の内容〕までも「コピー」したい場合には、`clone`という一般的なメソッドを用います。「メソッドの表記法」については次章の第5.3項で説明しますが、メソッドは多くのプログラミング言語に共通して見られる特徴ですので、すでに見たことがあるかもしれません。

実際の`clone`メソッドの事例がこちらです。

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

これで間違いなく実データが複写され、図4-3が示す状態が「意図的に」生み出されます。ヒープデータが実際に「複製」されるのです。

プログラム中に `clone` メソッドの呼び出しがある場合、そこでは何らかの通常でないコードが実行されており、その処理がプログラムの実行動作に与える影響は大きいと考えられます。何か普通と違うことが行なわれている目印というわけです。

<br>

### スタック上のデータだけを複製する：　「コピー Copy」

まだお話していない別の問題があります。以下は、リスト4-2を利用した整数を使用するプログラムで、問題なく動作する正しいものです。

```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

ところが、これは先程学んだばかりのことと矛盾していませんか？　`clone` メソッドを呼び出してもいないのに、変数 `x`は有効のままで、変数 `y` へ「移動」されていません。

この理由は、コンパイル時にデータ・サイズが判っている整数のような型は、全部がスタック上に格納されるので、実際のデータの値は即座に複製されるところにあります。つまり、変数 `y` を生成したあとに変数 `x` が有効であることを禁ずる理由がないのです。言い換えれば、ここでは、「深いコピー」と「浅いコピー」との区別がなく、`clone` メソッドを呼び出しても通常の「浅いコピー」と何ら異なることが起こらないので、そのままで構わない訳です。

Rustには、整数のように、スタック上に格納できる型に用いることのできる `Copy` <ruby>属性<rt>トレイト</rt></ruby>という特殊な < ruby>**注釈**<rt>アノテーション</rt></ruby> があります（この「**トレイト**」については [第10章](/10.0_Traits.md) にて取り上げます）。ある型が `Copy` トレイトを実装している場合、その型を用いた変数は「移動 move」されずに、「意図的に」複製されて、他の変数に代入されたあとでも元の変数は無効化されません。

Rustは、その型（またはその一部）が既に `Drop` <ruby>属性<rt>トレイト</rt></ruby>を実装してしているときには、その型に `Copy` 属性を付与させてくれません。その型の値がスコープ外になったときに特別な処理が必要で、その型に `Copy` 属性を付与すると、コンパイル時にエラーとなります。トレイト実装で、`Copy` 属性を付与する方法については、「[付録C：派生可能なトレイト](Appendix_C.md)」を参照してください。

では、どの型に `Copy` 属性を実装できるのでしょうか？　特定の型であれば念の為に公式ドキュメントを確認すればよいですが、一般論としては、単純なスカラー値の型には `Copy` を実装でき、メモリの割り当てを必要とするものや何らかのリソースであるものには `Copy` を使えません。以下は、`Copy` を使える型の一覧です。

+ すべての「整数型」、たとえば `u32`
+ 「ブール `bool` 型」（`true` / `false` という値を持つ論理値型）
+ すべての「浮動小数点型」、たとえば `f64`
+ 「文字 `char` 型」
+ 「タプル」（`Copy` を実装できる型のみを含む場合）、たとえば `(i32, i32)` には実装可能ですが、`(i32, String)` には実装できません。

<br>

## 所有権と関数

関数への値の受け渡しの仕組みは、値を変数に代入する場合と同様です。変数を関数に渡すには、代入を行なうのと同様、「移動 move」または「複製 copy」をします。リスト4-3は、変数がどこでスコープ内になりどこからスコープ外になるのかを示す「注釈」付きの事例でした。

```rust
fn main() {
    let s = String::from("hello");  ※ ここから変数`s`はスコープ内

    takes_ownership(s);             ※ 変数`s`の値が関数に移動...
                                    ※ ... 従って ここから無効化されます

    let x = 5;                      ※ ここから変数`x`がスコープ内

    makes_copy(x);                  ※ 変数`x`が関数に移動、
                                    ※ `i32`型は`Copy`なので、ここ以降も
                                    ※ 変数`x` は使用可能

} ※ ここで、変数`x`がスコープを抜け、変数`s`もスコープを抜けます。但し`s`の値は「移動」されているので
  ※ なにも起きません

fn takes_ownership(some_string: String) { ※ 引数`some_string`がスコープ内に入ります
    println!("{}", some_string);
} ※ 引数`some_string`がスコープ外となり、`drop`が呼び出されます。
  ※ 使用していたメモリ領域が解放されます

fn makes_copy(some_integer: i32) { ※ 引数`some_integer`がスコープ内に入ります
    println!("{}", some_integer);
} ※ ここで引数`some_integer`がスコープ外となりますが、なにも起きません

```

##### リスト4-3：　関数の所有権とスコープの範囲

<br>

もし `takes_ownership` 関数の呼び出しの後で変数 `s` を使おうとすると、Rustはコンパイル時エラーとなります。このような、プログラムを実行する前に問題点を検出する静的チェックの御蔭で、私たちプログラマは間違いを犯さずに居られています。`main`ブロックに変数`s`や`x`を使った処理を付け加えて、どの部分では正常に動作し、どこから「所有権の規則」によって使えなくなるのかを試してみてください。

<br>

## 戻り値とスコープの関係

戻り値にも所有権の移動があります。リスト4-4は戻り値のある関数の事例で、リスト4-3同様に解説付きで説明します。

```rust
fn main() {
    let s1 = gives_ownership();         ※ 関数`gives_ownership`が戻り値を変数`s1`に「移動 move」する

    let s2 = String::from("hello");     ※ 変数`s2`がスコープに入ります

    let s3 = takes_and_gives_back(s2);  ※ 変数`s2`が関数`takes_and_gives_back`に「移動 move」し、関数から戻り値が変数`s3`に「移動」します
} ※ ここで変数`s3`はスコープ外となり無効化されます。`s2`は「移動 move」されているのでなにも起きません
  ※ 変数`s1`がスコープ外となり、無効化されます

fn gives_ownership() -> String {             ※ 関数`gives_ownership`は戻り値を呼び出し元の関数に「移動 move」します

    let some_string = String::from("yours"); ※ 変数`some_string`がスコープ内になります

    some_string                              ※ `some_string`が返され、呼び出し元関数に「移動 move」されます
}

※ この関数は`String`型を受け取り、返します
fn takes_and_gives_back(a_string: String) -> String { ※ 引数`a_string`がスコープ内に入ります

    a_string  ※ `a_string`が返され、呼び出し元関数へ「移動 move」します
}
```

##### リスト4-4：　戻り値の所有権を移動する

変数の所有権は、毎回同じパターンを辿ります：　別の変数に値を代入すると、「移動 `move`」されます。 ヒープにデータが格納されている変数がスコープを抜けると、そのデータの所有権が別の変数に「移動 `move`」されていない限り、データは `drop` により解除されてしまいます。

このやり方は上手く機能しますが、すべての関数との所有権のやり取りはすこし面倒です。関数に値だけ使わせて、所有権は渡さないことにしたらどうでしょう。また、関数の処理結果である返したいと考えているデータに加えて、一旦渡したものまでも、再利用する場合には取り戻す必要があるというのも煩わしいことです。

Rustは、リスト4-5のように、二つ以上の要素の組み合わせで構成されたデータの型「タプル」を用いて複数の値を戻す方法を備えています。

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); 
    ※ `len()`は文字列 `String`のデータ長を返します

    (s, length)
}
```

##### リスト4-5：　引数の所有権を返す

<br>

しかし、この《毎回戻り値に「型」を再指定する》やり方では、あまりにも杓子定規すぎて、日常的に用いるべき手法としては手間が掛かり過ぎです。幸いなことに、Rustには、所有権を渡さずに値だけを利用できる「**参照** *reference*」という機能があります。

<br>
<br>

<hr>

<div align="center";>

[≪≪ 前に戻る](/04.0_Ownership.md)　　  | 　　[《目次》](/00.0_TOC.md)　　| 　　[次に進む　≫≫](/04.2_References&Borrowing.md)

</div>
